#include "cpp.hpp"

constexpr uint32_t PAGE_SIZE_SHIFT = 12;
constexpr uint32_t PAGE_SIZE = 1 << PAGE_SIZE_SHIFT;



#include "DDR5.cpu"

entity MemoryPacket
{
    uint32_t data[DRAM_STREAM_SIZE];
};


passive_component memory_controller_single
{
    enum memory_controller_state_t
    {
        IDLE,
        READ32_IN_PROGRESS,
        WRITE32_IN_PROGRESS
    };
    memory_controller_state_t state = memory_controller_state_t::IDLE;
    uint32_t requested_address;
    uint32_t pkt_index;
    MemoryPacket pkt;


    out_buffer<DRAM_command_type> command_type;
    out_buffer<bool> command_set;
    out_buffer<uint64_t> command_address;

    in_buffer<bool> DRAM_command_done;
    inout_buffer<uint32_t> DRAM_command_value;

    optional<MemoryPacket> check_read_finished()
    {
        switch (state)
        {
        default:
            assert(false);
            break;

        case memory_controller_state_t::READ32_IN_PROGRESS:
        {
            assert(pkt_index < DRAM_STREAM_SIZE);

            uint32_t value = DRAM_command_value.value();
            pkt.data[pkt_index] = value;
            pkt_index++;

            if (DRAM_command_done.value())
            {
                return optional<MemoryPacket>(pkt);
            }
        }
        }
        return optional<MemoryPacket>();
    }

    bool check_write_finished()
    {
        switch (state)
        {
        default:
            assert(false);
            break;

        case memory_controller_state_t::WRITE32_IN_PROGRESS:
        {
            assert(pkt_index < DRAM_STREAM_SIZE);

            uint32_t value = pkt.data[pkt_index];
            pkt_index++;
            DRAM_command_value.push(value);

            if (DRAM_command_done.value())
            {
                return true;
            }
        }
        }
        return false;
    }

    bool try_request_read(uint64_t address)
    {
        if (state != memory_controller_state_t::IDLE)
        {
            // need to wait for the DRAM module to be idle
            return false;
        }

        command_type.push(DRAM_command_type::READ32);
        command_address.push(requested_address);
        command_set.push(true);

        pkt_index = 0;

        state = memory_controller_state_t::READ32_IN_PROGRESS;
        return true;
    }

    bool try_request_write(uint64_t address, MemoryPacket value)
    {
        if (state != memory_controller_state_t::IDLE)
        {
            // need to wait for the DRAM module to be idle
            return false;
        }

        pkt = value;
        pkt_index = 0;

        command_type.push(DRAM_command_type::WRITE32);
        command_address.push(requested_address);
        command_set.push(true);

        state = memory_controller_state_t::WRITE32_IN_PROGRESS;
        return true;
    }
};

active_component memory_controller_dispatcher
{
    enum memory_controller_dispatcher_t
    {
        IDLE,
        ACTIVE_A_READ,
        ACTIVE_B_READ,
        ACTIVE_A_WRITE,
        ACTIVE_B_WRITE,
    };

    memory_controller_dispatcher_t state = memory_controller_dispatcher_t::IDLE;

    in_buffer<bool> command_set;
    in_buffer<DRAM_command_type> command_type;
    in_buffer<uint64_t> command_address;

    out_buffer<bool> command_done;
    inout_buffer<MemoryPacket> command_rw;

    memory_controller_single DRAM_A;
    memory_controller_single DRAM_B;

    void tick()
    {
        switch (state)
        {
        case memory_controller_dispatcher_t::IDLE:
            check_for_new_command();
            break;
        case memory_controller_dispatcher_t::ACTIVE_A_READ:
            check_for_read_completion_A();
            break;
        case memory_controller_dispatcher_t::ACTIVE_B_READ:
            check_for_read_completion_B();
            break;
        case memory_controller_dispatcher_t::ACTIVE_A_WRITE:
            check_for_write_completion_A();
            break;
        case memory_controller_dispatcher_t::ACTIVE_B_WRITE:
            check_for_write_completion_B();
            break;
        }
    }

    void check_for_read_completion_A()
    {
        const auto ret = DRAM_A.check_read_finished();
        if (ret.available)
        {
            state = memory_controller_dispatcher_t::IDLE;
            command_rw.push(ret.m_value);
            command_done.push(true);
        }
    }

    void check_for_read_completion_B()
    {
        const auto ret = DRAM_B.check_read_finished();
        if (ret.available)
        {
            state = memory_controller_dispatcher_t::IDLE;
            command_rw.push(ret.m_value);
            command_done.push(true);
        }
    }

    void check_for_write_completion_A()
    {
        if (DRAM_A.check_write_finished())
        {
            state = memory_controller_dispatcher_t::IDLE;
            command_done.push(true);
        }
    }

    void check_for_write_completion_B()
    {
        if (DRAM_B.check_write_finished())
        {
            state = memory_controller_dispatcher_t::IDLE;
            command_done.push(true);
        }
    }

    void check_for_new_command()
    {
        if (!command_set.value())
        {
            return;
        }

        uint64_t address = command_address.value();

        switch (command_type.value())
        {
        case DRAM_command_type::READ32:
        {
            if (is_for_A(address))
            {
                if (DRAM_A.try_request_read(command_address.value()))
                {
                    state = memory_controller_dispatcher_t::ACTIVE_A_READ;
                }
            }
            else
            {
                if (DRAM_B.try_request_read(command_address.value()))
                {
                    state = memory_controller_dispatcher_t::ACTIVE_B_READ;
                }
            }
            break;
        }

        case DRAM_command_type::WRITE32:
        {
            if (is_for_A(address))
            {
                if (DRAM_A.try_request_write(command_address.value(), command_rw.value()))
                {
                    state = memory_controller_dispatcher_t::ACTIVE_A_WRITE;
                }
            }
            else
            {
                if (DRAM_B.try_request_write(command_address.value(), command_rw.value()))
                {
                    state = memory_controller_dispatcher_t::ACTIVE_B_WRITE;
                }
            }
            break;
        }
        }
    }

    bool is_for_A(uint64_t v) const
    {
        uint32_t page = v >> PAGE_SIZE_SHIFT;
        return page & 1;
    }
};

active_component L1_insn_cache{
    void tick(){}};

active_component L1_data_cache{};

enum instruction_kind
{
    NOP,
    ADD
};

active_component MMU{

};

entity instruction
{
    instruction_kind type;
};

active_component instruction_fetcher{};

active_component instruction_decoder{};

active_component instruction_executor{};

active_component instruction_store{};

cpu main
{
    DRAM_channel DRAM_ch_A;
    DRAM_channel DRAM_ch_B;

    MMU mmu;

    instruction_fetcher fetcher;
};
